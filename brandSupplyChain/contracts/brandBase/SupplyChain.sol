pragma solidity ^0.5.0;

import "../brandAccessControl/BrandRole.sol";
import "../brandAccessControl/DistributorRole.sol";
import "../brandAccessControl/StoreRole.sol";
import "../brandAccessControl/ConsumerRole.sol";
import "../brandCore/Ownable.sol";

// Define a contract 'Supplychain'
contract SupplyChain is BrandRole, DistributorRole, StoreRole, ConsumerRole {

    // Define 'owner'
    address payable owner;

    // Define a variable called 'upc' for Universal Product Code (UPC)
    uint    upc;

    // Define a variable called 'sku' for Stock Keeping Unit (SKU)
    uint    sku;

    // Define a public mapping 'items' that maps the UPC to an Item.
    mapping (uint => Item) items;

    // Define a public mapping 'itemsHistory' that maps the UPC to an array of TxHash,
    // that track its journey through the supply chain -- to be sent from DApp.
    mapping (uint => string[]) itemsHistory;

    // Define enum 'State' with the following values:
    enum State
    {
        Produced,       // 0
        ForSale,        // 1
        Sold,           // 2
        Collected,      // 3
        Sent,           // 4
        Received,       // 5
        ForPurchase,    // 6
        Purchased       // 7
    }

    State constant defaultState = State.Produced;

    // Define a struct 'Item' with the following fields:
    struct Item {
        uint    sku;                    // Stock Keeping Unit (SKU)
        uint    upc;                    // Universal Product Code (UPC), generated by the Brand, goes on the package, can be verified by the Consumer
        address ownerID;                // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        address originBrandID;          // Metamask-Ethereum address of the Brand
        string  originBrandName;        // Brand Name
        string  originBrandInformation; // Brand Information
        string  originBrandLatitude;    // Brand Latitude
        string  originBrandLongitude;   // Brand Longitude
        uint    productID;              // Product ID potentially a combination of upc + sku
        string  productNotes;           // Product Notes
        State   itemState;              // Product State as represented in the enum above
        address distributorID;          // Metamask-Ethereum address of the Distributor
        address storeID;                // Metamask-Ethereum address of the Store
        address consumerID;             // Metamask-Ethereum address of the Consumer
    }

    // Define 8 events with the same 8 state values and accept 'upc' as input argument
    event Produced(uint upc);
    event ForSale(uint upc);
    event Sold(uint upc);
    event Collected(uint upc);
    event Sent(uint upc);
    event Received(uint upc);
    event ForPurchase(uint upc);
    event Purchased(uint upc);

    // Define a modifer that checks to see if msg.sender == owner of the contract
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    // Define a modifer that verifies the Caller
    modifier verifyCaller (address _address) {
        require(msg.sender == _address);
        _;
    }

    // Define a modifier that checks if the paid amount is sufficient to cover the price
    // modifier paidEnough(uint _price) {
    //     require(msg.value >= _price);
    //     _;
    // }

    // Define a modifier that checks the price and refunds the remaining balance
    // modifier checkValue(uint _upc) {
    //     _;
    //     uint _price = items[_upc].productPrice;
    //     uint amountToReturn = msg.value - _price;
    //     items[_upc].consumerID.transfer(amountToReturn);
    // }

    // Define a modifier that checks if an item.state of a upc is Produced
    modifier produced(uint _upc) {
        require(items[_upc].itemState == State.Produced);
        _;
    }

    // Define a modifier that checks if an item.state of a upc is ForSale
    modifier forSale(uint _upc) {
        require(items[_upc].itemState == State.ForSale);
        _;
    }

    // Define a modifier that checks if an item.state of a upc is Sold
    modifier sold(uint _upc) {
        require(items[_upc].itemState == State.Sold);
        _;
    }

    // Define a modifier that checks if an item.state of a upc is Sent
    modifier sent(uint _upc) {
        require(items[_upc].itemState == State.Sent);
        _;
    }

    // Define a modifier that checks if an item.state of a upc is Collected
    modifier collected(uint _upc) {
        require(items[_upc].itemState == State.Collected);
        _;
    }

    // Define a modifier that checks if an item.state of a upc is Received
    modifier received(uint _upc) {
        require(items[_upc].itemState == State.Received);
        _;
    }

    // Define a modifier that checks if an item.state of a upc is ForPurchase
    modifier forPurchase(uint _upc) {
        require(items[_upc].itemState == State.ForPurchase);
        _;
    }

    // Define a modifier that checks if an item.state of a upc is Purchased
    modifier purchased(uint _upc) {
        require(items[_upc].itemState == State.Purchased);
        _;
    }

    // In the constructor set 'owner' to the address that instantiated the contract
    // and set 'sku' to 1
    // and set 'upc' to 1
    constructor() public payable {
        owner = msg.sender;
        sku = 1;
        upc = 1;
    }

    // Define a function 'kill' if required
    function kill() public {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }

    // Define a function 'produceItem' that allows a brand to mark an item 'Produced'
    function produceItem(
        uint    _upc,
        address _originBrandID,
        string memory  _originBrandName,
        string memory  _originBrandInformation,
        string memory  _originBrandLatitude,
        string memory  _originBrandLongitude,
        string memory  _productNotes
        )
        public
    {
        // Add the new item as part of Produce
        uint _productID = sku + _upc;
        Item memory item = Item(
            sku,                        // sku
            _upc,                       // upc
            _originBrandID,             // ownerID
            _originBrandID,             // originBrandID
            _originBrandName,           // originBrandName
            _originBrandInformation,    // originBrandInformation
            _originBrandLatitude,       // originBrandLatitude
            _originBrandLongitude,      // originBrandLongitude
            _productID,                 // productID
            _productNotes,              // productNotes
            State.Produced,             // itemState
            address(0),                 // distributorID
            address(0),                 // storeID
            address(0)                  // consumerID
        );

        items[_upc] = item;
        // Increment sku
        sku = sku + 1;
        // Emit the appropriate event
        emit Produced(_upc);
    }

    // Define a function 'advertiseItem' that allows a brand to mark an item 'Collected'
    function advertiseItem(uint _upc) public produced(_upc) onlyBrand()
    {
        // Update the appropriate fields
        items[_upc].itemState = State.ForSale;
        // Emit the appropriate event
        emit ForSale(_upc);
    }

    // Define a function 'buyItem' that allows a distributor to mark an item 'sold'
    function buyItem(uint _upc) public forSale(_upc) onlyDistributor()
    {
        // Update the appropriate fields
        items[_upc].ownerID = msg.sender;
        items[_upc].distributorID = msg.sender;
        items[_upc].itemState = State.Sold;
        // Emit the appropriate event
        emit Sold(_upc);
    }

    // Define a function 'sellItem' that allows a distributor to mark an item 'collected'
    function collectItem(uint _upc) public sold(_upc) onlyDistributor()
    {
        // Update the appropriate fields
        items[_upc].itemState = State.Collected;
        // Emit the appropriate event
        emit Collected(_upc);
    }

    // Define a function 'sendItem' that allows a distributor to mark an item 'sent'
    function sendItem(uint _upc) public collected(_upc) onlyDistributor()
    {
        // Update the appropriate fields - ownerID, distributorID, itemState
        items[_upc].itemState = State.Sent;
        // emit the appropriate event
        emit Sent(_upc);
    }

    // Define a function 'receiveItem' that allows a store to mark an item 'Received'
    function receiveItem(uint _upc) public sent(_upc) onlyStore()
    {
        // Update the appropriate fields - ownerID, storeID, itemState
        items[_upc].ownerID = msg.sender;
        items[_upc].storeID = msg.sender;
        items[_upc].itemState = State.Received;
        // Emit the appropriate event
        emit Received(_upc);
    }

    // Define a function 'storeItem' that allows a store to mark an item 'ForPurchase'
    function storeItem(uint _upc) public received(_upc) onlyStore()
    {
        // Update the appropriate fields
        items[_upc].itemState = State.ForPurchase;
        // Emit the appropriate event
        emit ForPurchase(_upc);
    }

    // Define a function 'purchaseItem' that allows a consumer to mark an item 'Purchased'
    // Use the above modifiers to check if the item is received
    function purchaseItem(uint _upc) public forPurchase(_upc) onlyConsumer()
    {
        // Update the appropriate fields - ownerID, consumerID, itemState
        items[_upc].ownerID = msg.sender;
        items[_upc].consumerID = msg.sender;
        items[_upc].itemState = State.Purchased;
        // Emit the appropriate event
        emit Purchased(_upc);
    }

    // Define a function 'fetchItemBufferOne' that fetches the data
    function fetchItemBufferOne(uint _upc) public view
        returns(
            uint itemSKU,
            uint itemUPC,
            address ownerID,
            address originBrandID,
            string memory originBrandName,
            string memory originBrandInformation,
            string memory originBrandLatitude,
            string memory originBrandLongitude
        )
    {
        // Assign values to the 8 parameters
        Item memory item = items[_upc];

        itemSKU = item.sku;
        itemUPC = item.upc;
        ownerID = item.ownerID;
        originBrandID = item.originBrandID;
        originBrandName = item.originBrandName;
        originBrandInformation = item.originBrandInformation;
        originBrandLatitude = item.originBrandLatitude;
        originBrandLongitude = item.originBrandLongitude;

        return ( itemSKU, itemUPC, ownerID, originBrandID, originBrandName, originBrandInformation,
                originBrandLatitude, originBrandLongitude );
    }

    // Define a function 'fetchItemBufferTwo' that fetches the data
    function fetchItemBufferTwo(uint _upc) public view
        returns(
            uint    itemSKU,
            uint    itemUPC,
            uint    productID,
            string memory  productNotes,
            uint    itemState,
            address distributorID,
            address storeID,
            address consumerID
        )
    {
        // Assign values to the 8 parameters
        Item memory item = items[_upc];

        itemSKU = item.sku;
        itemUPC = item.upc;
        productID = item.productID;
        productNotes = item.productNotes;
        itemState = uint(item.itemState);
        distributorID = item.distributorID;
        storeID = item.storeID;
        consumerID = item.consumerID;

        return ( itemSKU, itemUPC, productID, productNotes, itemState, distributorID, storeID, consumerID );
    }
}
